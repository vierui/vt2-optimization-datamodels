\newpage
\section{Methodology}

This section describes how data move through the tool, how the optimisation model was upgraded from an 
LP to a MILP, how the forecasting module is built, and how the code is organised.  Section\,4 gives the 
full maths, Section\,5 the code.

\subsection{Data Pipeline and Representative Weeks}

\paragraph{Folder layout}

\begin{verbatim}
data/
 ├─ grid/                  # static network data
 │   ├─ analysis.json      # horizon, load-growth, season weights
 │   ├─ buses.csv
 │   ├─ lines.csv
 │   ├─ generators.csv
 │   ├─ loads.csv
 │   └─ storage_units.csv
 └─ profiles/              # time-series in UTC
     ├─ load-2023.csv
     ├─ wind-2023.csv
     └─ solar-2023.csv
\end{verbatim}

\paragraph{Pre-processing flow (\texttt{scripts/pre.py})}

\begin{enumerate}
\item Load the grid CSVs and \texttt{analysis.json}.  
\item Read the raw time-series files into pandas, then cut three
      168\,h blocks, one per season.  
\item Write the sliced DataFrames into a dictionary \texttt{seasons\_profiles}.  
      The dictionary holds:
      \(\{\,\text{loads},\,\text{generators},\,\text{wind\_df},\,\text{solar\_df},\,\text{hours}=168\}\).  
\item Pass \texttt{grid\_data}, \texttt{seasons\_profiles}, and the season weights
      to the optimisation layer.
\end{enumerate}

All heavy joins run inside DuckDB.
The only cleaning step is a timestamp alignment to full hours; out-of-range
values are clipped, missing values are linearly interpolated.

\subsection{Linear-to-Mixed-Integer Upgrade}

The old LP solved one year and assumed all assets were given.  
The new MILP decides what to build and when, for several years.

\paragraph{What changed}

\begin{itemize}
\item \textbf{New binaries}  
      \(\textsf{build}_{g,y}\), \(\textsf{build}_{s,y}\) – build in year \(y\).  
      \(\textsf{uc}_{g,y,t}\) – on or off for thermal units.  
      \(\textsf{installed}_{g,y}\), \(\textsf{installed}_{s,y}\) are implied by
      the build binaries.  
\item \textbf{New constraints}  
      Lifetime chunk rule, one build per asset per rolling lifetime.  
      UC minimum up and down time.  
      Annual annuity charge equals \(\textsf{installed}\times A_a\).  
      Storage end-of-week state free within 10\,\% of capacity.  
\item \textbf{Solver}  
      CVXPY \(+\) CPLEX, 10 threads, 18 min limit, 1 % gap.  
\end{itemize}

The flat dictionaries in \texttt{optimization.py} build one vector per
asset–year–season, so model size scales linearly.

\subsection{Forecasting Module}

The forecaster runs outside the MILP and supplies day-ahead profiles.

\paragraph{Features}

\begin{itemize}
\item Calendar: hour\_sin, hour\_cos, month\_sin, month\_cos  
\item Lags: values at \(t-1\), \(t-24\), \(t-168\)  
\item Rolling means: 24 h, 168 h  
\item Weather: ERA5 temperature, cloud, diffuse and direct irradiance  
\item Solar geometry: sun height and airmass from PVLib  
\end{itemize}

\paragraph{Model ladder}

Start with SARIMA, then Gradient Boosted Trees, then XGBoost.
Try LSTM only if MAE is still above the 5 % target.
Optuna tunes hyper-parameters with a five-fold
time split.

\paragraph{Error scenarios}

Point forecast, static \(\pm\sigma\) band, 100
Monte-Carlo draws with block bootstrap, horizon-scaled band,
and a single worst-case envelope.
Each scenario re-runs the MILP with the same random seed.

\subsection{Code Architecture}

\begin{itemize}
\item \texttt{pre.py} – data extraction and season slicing  
\item \texttt{network.py} – light containers for one season and for the
      multi-season network  
\item \texttt{optimization.py} – builds and solves the MILP  
\item \texttt{post.py} – plots, Gantt timeline, summary JSON  
\item \texttt{forecast/} – forecasting scripts and MLflow tracking  
\end{itemize}

Poetry pins all package versions.
Pytest covers unit conversions, key builders, and output schema.
A GitHub action runs \texttt{pytest} and \texttt{black --check} on every push.